[["index.html", "ndexr: A Hanbook on R Chapter 1 Prerequisites", " ndexr: A Hanbook on R Freddy Ray Drennan 2021-11-15 Chapter 1 Prerequisites Install R Install R Studio Windows Only: Install RTools When installed, run in the RStudio Console: write('PATH=\"${RTOOLS40_HOME}\\\\usr\\\\bin;${PATH}\"', file = \"~/.Renviron\", append = TRUE) Windows Only: Install WSL2 Computer should be completely updated before install. Install Git Create Github Account Fork r-handbook Install Docker and Docker Compose Create AWS Account Billing will be discussed in the course, but dont expect to pay much - i.e., 10-20 dollars a month for high course activity. Remember to stop EC2 servers when we begin using them. AWS is polite about your first few refund requests. Create Reddit Account Follow Instructions here Make sure you install the tidyverse packages. install.packages(&#39;tidyverse&#39;) "],["functions.html", "Chapter 2 Functions 2.1 Vectors 2.2 Indexes 2.3 What are Functions? 2.4 Sequences", " Chapter 2 Functions 2.1 Vectors Vectors are containers information of similar type. You can think of them as having \\(1\\ * \\ n\\) cells where \\(n\\) is any positive integer, and make up the rows and columns of tables. Vectors have a few components that make them special. First, they always contain the same type of value. R has many different data types, but the most common are numeric, character, and logical (TRUE/FALSE). Rule 1: Vectors only contain one type of data. Rule 2: Vectors are always \\(1xn\\) dimensional, \\(1xn=n\\) where \\(n\\) is the length of the vector. Rule 3: Vectors dont always have names, but should if it makes sense. Functions are containers where anything or nothing can happen, but whatever happens, it happens the same way every single time. They allow for generalization of complicated ideas and routines that we wish to repeat over and over again. A function may have an input, but no output. It may have an output, but no input, both or none. If its something you need to do repeatedly, or containing code makes your program easier to read, then write a function for that process. Rule 4: Functions have inputs, outputs, and a body. A function can have multiple outputs, but given a particular set of inputs, the solution should never change assuming you are not developing a function with randomness built in. R has a built-in constant called letters. This means that no matter where you are writing R, letters will be available to you. We see that letters is a character vector in our program below, and use the composition of functions to create a program that describes letters. print(letters) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; Next, we can use some functions which take in pretty much any object that exists in R and spits back information regarding the letters data. print_information &lt;- function(x) { variable_name = deparse1(substitute(x)) length_x = length(x) typeof_x &lt;- typeof(x) is_vec_x &lt;- is.vector(x) meta_list &lt;- list( length = length_x, type = typeof_x, is_vector = is_vec_x ) cli::cli_alert(&#39;Information about {variable_name}&#39;) cli::cli_alert_info(&quot;{variable_name} is a 1x{length_x} dimensional&quot;) cli::cli_alert_info(&quot;&quot;) purrr::iwalk(meta_list, function(x, index) { cli::cli_alert_info(glue::glue(&#39;{index} {x} is type {typeof(x)}&#39;)) }) return(meta_list) } cli::cli_alert_info(&#39;Execute print_information&#39;) ## i Execute print_information output &lt;- print_information(mtcars) ## &gt; Information about mtcars ## i mtcars is a 1x11 dimensional ## i ## i length 11 is type integer ## i type list is type character ## i is_vector FALSE is type logical cli::cli_alert_success(&#39;Execute print_information complete&#39;) ## v Execute print_information complete print(output) ## $length ## [1] 11 ## ## $type ## [1] &quot;list&quot; ## ## $is_vector ## [1] FALSE We can take this information and put it in a list. A list holds whatever we want to put inside it. The left side is the name that the object will get within the list, the right side the object itself. 2.2 Indexes Consider the values \\(1, 2,  n\\), where \\(n\\) is any positive integer. Indexing is just our way of specifying the location of something. An index in R always starts at 1 and extends through the integers until n equals the number of items we are counting. seq(from = 1, to = 10) ## [1] 1 2 3 4 5 6 7 8 9 10 What is special about starting the sequence at 1 is that it creates a vector of integers that also match their location in the vector. When you think about vectors, remember that whether they be logical (TRUE/FALSE), numeric (1.1, 2), integer (1, 4), or character (\"a\", \"cat\"), there is always an integer associated with its position in the object. message(&#39;Full letters vector&#39;) ## Full letters vector print(letters) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; message(&#39;Selecting the first 10 values&#39;) ## Selecting the first 10 values letters[seq(from = 1, to = 10)] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; 2.3 What are Functions? We can assign this integer vector to a variable called data . When we assign something to a variable, we can take it with us to use in other parts of our program. We will use a built in constant that R provides called LETTERS which is a character vector containing the 26 letters of the alphabet capitalized. data = seq(1, 10) data &lt;- setNames(data, LETTERS[data]) print(data) ## A B C D E F G H I J ## 1 2 3 4 5 6 7 8 9 10 Maybe we are interested in how long the vector is, or what its names are. length(data) ## [1] 10 class(data) ## [1] &quot;integer&quot; names(data) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; 2.4 Sequences Suppose we have the function \\(g(x) = x^2\\), and want to use it. We can define the function below, and call it square. The function can be named whatever we like, square could be platypus for all I care. It doesnt really matter, except to whoever is reading your program - likely you at a later, more forgetful date. Generally, we want to name the things we create something useful, so that when we are reading our program, we understand what is happening. Naming functions is a square = function(x) x^2 square(3) # ## [1] 9 "],["literature.html", "Chapter 3 Literature", " Chapter 3 Literature Here is a review of existing methods. "],["methods.html", "Chapter 4 Methods", " Chapter 4 Methods We describe our methods in this chapter. "],["applications.html", "Chapter 5 Applications 5.1 Example one 5.2 Example two", " Chapter 5 Applications Some significant applications are demonstrated in this chapter. 5.1 Example one 5.2 Example two "],["final-words.html", "Chapter 6 Final Words", " Chapter 6 Final Words We have finished a nice book. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
